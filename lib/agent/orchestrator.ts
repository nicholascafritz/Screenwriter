// ---------------------------------------------------------------------------
// AI Agent -- Orchestrator Types & Utilities
// ---------------------------------------------------------------------------
//
// Provides the types and utility functions for the autonomous agent mode.
// The actual AI conversation loop lives in the API route; this module
// defines the data structures for plans, step tracking, and state
// formatting so that both the API route and the UI can share a consistent
// representation.
//
// Usage:
//   import {
//     type AgentPlan,
//     type AgentState,
//     type AgentStep,
//     createAgentPlan,
//     formatAgentContext,
//   } from '@/lib/agent/orchestrator';
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

/**
 * A single step in an agent execution plan.
 */
export interface AgentStep {
  /** Human-readable description of what this step will do. */
  description: string;

  /** Current execution state of the step. */
  status: 'pending' | 'in_progress' | 'completed';
}

/**
 * A structured plan that the agent follows when executing a complex task.
 *
 * The plan is initially created as a placeholder with generic steps.
 * The actual plan is generated by the Claude API in the agent API route
 * and replaces the placeholder once available.
 */
export interface AgentPlan {
  /** Ordered list of steps to execute. */
  steps: AgentStep[];

  /** High-level description of the approach the agent will take. */
  approach: string;
}

/**
 * The runtime state of the agent during execution.
 */
export interface AgentState {
  /** The current execution plan, or null if no plan has been created yet. */
  plan: AgentPlan | null;

  /** Zero-based index of the step currently being executed. */
  currentStep: number;

  /** Whether the agent loop is currently running. */
  isRunning: boolean;

  /** Whether the agent has been paused by the user. */
  isPaused: boolean;
}

// ---------------------------------------------------------------------------
// Plan creation
// ---------------------------------------------------------------------------

/**
 * Create a placeholder agent plan for a given task.
 *
 * This returns a generic multi-step plan that the API route will replace
 * with a more specific plan once the LLM has analyzed the screenplay and
 * the task.  The placeholder gives the UI something to display immediately
 * while the actual planning happens asynchronously.
 *
 * @param task       - The user's task description.
 * @param _screenplay - The current screenplay text (reserved for future
 *                      heuristics; currently unused in the placeholder).
 * @returns A generic agent plan.
 */
export function createAgentPlan(task: string, _screenplay: string): AgentPlan {
  return {
    approach: `Executing task: ${task}`,
    steps: [
      {
        description: 'Analyze the current screenplay and understand its structure',
        status: 'pending',
      },
      {
        description: 'Plan the specific changes needed to accomplish the task',
        status: 'pending',
      },
      {
        description: 'Execute the planned changes',
        status: 'pending',
      },
      {
        description: 'Review the changes for consistency and quality',
        status: 'pending',
      },
    ],
  };
}

// ---------------------------------------------------------------------------
// State formatting
// ---------------------------------------------------------------------------

/**
 * Format the current agent state into a human-readable string suitable
 * for display in the chat UI or for inclusion in a status message.
 *
 * @param state - The current agent state.
 * @returns A formatted multi-line string describing the agent's progress.
 */
export function formatAgentContext(state: AgentState): string {
  const lines: string[] = [];

  // Header with running status.
  if (state.isPaused) {
    lines.push('Agent: PAUSED');
  } else if (state.isRunning) {
    lines.push('Agent: RUNNING');
  } else {
    lines.push('Agent: IDLE');
  }

  if (!state.plan) {
    lines.push('No plan created yet.');
    return lines.join('\n');
  }

  lines.push('');
  lines.push(`Approach: ${state.plan.approach}`);
  lines.push('');

  // Progress summary.
  const completed = state.plan.steps.filter((s) => s.status === 'completed').length;
  const total = state.plan.steps.length;
  lines.push(`Progress: ${completed}/${total} steps completed`);
  lines.push('');

  // Step list.
  for (let i = 0; i < state.plan.steps.length; i++) {
    const step = state.plan.steps[i];
    let marker: string;

    switch (step.status) {
      case 'completed':
        marker = '[x]';
        break;
      case 'in_progress':
        marker = '[>]';
        break;
      case 'pending':
        marker = '[ ]';
        break;
    }

    lines.push(`  ${marker} ${i + 1}. ${step.description}`);
  }

  return lines.join('\n');
}

// ---------------------------------------------------------------------------
// State factory
// ---------------------------------------------------------------------------

/**
 * Create a fresh initial agent state.
 */
export function createInitialAgentState(): AgentState {
  return {
    plan: null,
    currentStep: 0,
    isRunning: false,
    isPaused: false,
  };
}

/**
 * Advance the agent state to the next step.
 *
 * Marks the current step as completed and moves `currentStep` forward.
 * If there are remaining steps, the next step is marked as in_progress.
 * Returns a new state object (immutable update).
 */
export function advanceAgentStep(state: AgentState): AgentState {
  if (!state.plan) return state;

  const steps = state.plan.steps.map((step, i) => {
    if (i === state.currentStep) {
      return { ...step, status: 'completed' as const };
    }
    if (i === state.currentStep + 1) {
      return { ...step, status: 'in_progress' as const };
    }
    return step;
  });

  const nextStep = state.currentStep + 1;
  const isRunning = nextStep < steps.length;

  return {
    ...state,
    plan: { ...state.plan, steps },
    currentStep: nextStep,
    isRunning,
  };
}

/**
 * Update the plan in the agent state with a new plan from the LLM.
 *
 * This replaces the placeholder plan with the actual plan and marks the
 * first step as in_progress.
 */
export function updateAgentPlan(
  state: AgentState,
  plan: AgentPlan,
): AgentState {
  const steps = plan.steps.map((step, i) => ({
    ...step,
    status: i === 0 ? ('in_progress' as const) : step.status,
  }));

  return {
    ...state,
    plan: { ...plan, steps },
    currentStep: 0,
    isRunning: true,
  };
}
